[{"categories":null,"content":"问题 var lock sync.RWMutex var wg *sync.WaitGroup func Writer(ctx context.Context) { ticker := time.NewTicker(10 * time.Millisecond) defer ticker.Stop() for { select { case \u003c-ticker.C: lock.Lock() time.Sleep(5 * time.Millisecond) lock.Unlock() case \u003c-ctx.Done(): return } } } func Reader() { defer wg.Done() lock.RLock() time.Sleep(1000 * time.Millisecond) defer lock.RUnlock() lock.RLock() time.Sleep(100 * time.Millisecond) defer lock.RUnlock() } func main() { wg = new(sync.WaitGroup) wg.Add(1) ctx, cancel := context.WithCancel(context.Background()) defer cancel() go Writer(ctx) go Reader() wg.Wait() } 执行上面的代码，会发生死锁，为什么？ 初次使用可能意识不到，认为同一个协程两次获取读锁，也没什么大不了的，实际上 go 的读写锁是禁止递归获取读锁的。设想如果 Reader 先获取到读锁，然后 Writer 试图获取写锁，写锁会因为有 goroutine 持有读锁而堵塞在加锁的过程中，然后 Reader 尝试再次获取读锁，会因为有 goroutine 试图持有写锁而堵塞，从而形成死锁。 如果不了解读写锁的底层实现，看了上面的文字还是有可能领会不到为什么会出现死锁，为什么 Reader 再次获取读锁会仅仅应为 goroutine 试图持有写锁而堵塞，仅仅是试图都不行？ ","date":"2024-05-01","objectID":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/:1:0","tags":["language/go"],"title":"go 读写锁源码阅读","uri":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"categories":null,"content":"源码 go 的版本为 1.23.0 读写锁的结构如下： type RWMutex struct { w Mutex // held if there are pending writers writerSem uint32 // semaphore for writers to wait for completing readers readerSem uint32 // semaphore for readers to wait for completing writers readerCount atomic.Int32 // number of pending readers readerWait atomic.Int32 // number of departing readers } w 是多个写者尝试申请写锁时的互斥锁，用于选出一位优先的写者。 readerCount 是所有的读者数量（包括持有读锁和等待读锁的），readerWait 是写者尝试获取写锁时读者的数量（用于尽力实现公平调度）。 rwmutexMaxReaders 是包中的一个常量，大小 $2^{30}$，表示最多读者数量。 ","date":"2024-05-01","objectID":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/:2:0","tags":["language/go"],"title":"go 读写锁源码阅读","uri":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"categories":null,"content":"加写锁 func (rw *RWMutex) Lock() { if race.Enabled { _ = rw.w.state race.Disable() } // First, resolve competition with other writers. rw.w.Lock() // Announce to readers there is a pending writer. r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders // Wait for active readers. if r != 0 \u0026\u0026 rw.readerWait.Add(r) != 0 { runtime_SemacquireRWMutex(\u0026rw.writerSem, false, 0) } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026rw.readerSem)) race.Acquire(unsafe.Pointer(\u0026rw.writerSem)) } } 关于 race 的部分可以忽略。可以看到首先加写者的竞争锁，然后 rw.readerCount.Add(-rwmutexMaxReaders)，这是将 readerCount 置为负数，目的可以见加读锁的过程。用 r 获取到了所有读者的数量，之后将 readerWait 置为 r，然后等待其他 r 位读者释放读锁发送写信号量。 ","date":"2024-05-01","objectID":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/:2:1","tags":["language/go"],"title":"go 读写锁源码阅读","uri":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"categories":null,"content":"加读锁 func (rw *RWMutex) RLock() { if race.Enabled { _ = rw.w.state race.Disable() } if rw.readerCount.Add(1) \u003c 0 { // A writer is pending, wait for it. runtime_SemacquireRWMutexR(\u0026rw.readerSem, false, 0) } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026rw.readerSem)) } } 首先将读者数量加一，然后奇怪的事情来了——为什么要检查读者数量是否小于 0？可以看到注释锁小于 0 意味着有写者在前面，还记得写者申请写锁的时候 rw.readerCount.Add(-rwmutexMaxReaders) 将读者数量置为负数来表明有写者吗？这就呼应上了。如果前面有写者，尝试获取读者的协程会堵塞等待读信号量。这个信号量由谁来发送呢？可以带着这个疑问看写锁释放的过程。 但是为什么要这样（堵塞）做呢？公平性。如果不让新来的读者堵塞在写者后面，会出现写者饥饿，长时间获取不到锁。 ","date":"2024-05-01","objectID":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/:2:2","tags":["language/go"],"title":"go 读写锁源码阅读","uri":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"categories":null,"content":"释放读锁 func (rw *RWMutex) RUnlock() { if race.Enabled { _ = rw.w.state race.ReleaseMerge(unsafe.Pointer(\u0026rw.writerSem)) race.Disable() } if r := rw.readerCount.Add(-1); r \u003c 0 { // Outlined slow-path to allow the fast-path to be inlined rw.rUnlockSlow(r) } if race.Enabled { race.Enable() } } func (rw *RWMutex) rUnlockSlow(r int32) { if r+1 == 0 || r+1 == -rwmutexMaxReaders { race.Enable() fatal(\"sync: RUnlock of unlocked RWMutex\") } // A writer is pending. if rw.readerWait.Add(-1) == 0 { // The last reader unblocks the writer. runtime_Semrelease(\u0026rw.writerSem, false, 1) } } 过程是：读者数量减 1，然后检查读者数量是否为负，如果为负，意味有写者在等待前面的读者释放，这个时候就要检查是否轮到写者上锁了。可以看到检查的过程 rUnlockSlow：首先将写者前面的读者数量 readerWait 减 1，然后检查是否为 0，为 0 意味没有读者了，可以给写者发送信号量了。 ","date":"2024-05-01","objectID":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/:2:3","tags":["language/go"],"title":"go 读写锁源码阅读","uri":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"categories":null,"content":"释放写锁 func (rw *RWMutex) Unlock() { if race.Enabled { _ = rw.w.state race.Release(unsafe.Pointer(\u0026rw.readerSem)) race.Disable() } // Announce to readers there is no active writer. r := rw.readerCount.Add(rwmutexMaxReaders) if r \u003e= rwmutexMaxReaders { race.Enable() fatal(\"sync: Unlock of unlocked RWMutex\") } // Unblock blocked readers, if any. for i := 0; i \u003c int(r); i++ { runtime_Semrelease(\u0026rw.readerSem, false, 0) } // Allow other writers to proceed. rw.w.Unlock() if race.Enabled { race.Enable() } } 写锁释放需要做两个事情： 给排在写者后面的读者释放信号量 释放写者尝试加写者锁时获取到的互斥锁，供后续的写者获取 ","date":"2024-05-01","objectID":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/:2:4","tags":["language/go"],"title":"go 读写锁源码阅读","uri":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"categories":null,"content":"总结 回到刚才的问题，当 Reader 获取到第一个读锁时，Writer 尝试获取写锁，会堵塞在源码的： if r != 0 \u0026\u0026 rw.readerWait.Add(r) != 0 { runtime_SemacquireRWMutex(\u0026rw.writerSem, false, 0) } 而当 Reader 尝试获取第二个读锁的时候，Reader 会堵塞在： if rw.readerCount.Add(1) \u003c 0 { // A writer is pending, wait for it. runtime_SemacquireRWMutexR(\u0026rw.readerSem, false, 0) } 两者互相堵塞，导致死锁。 这一切的根源是什么呢？公平性，为了保证公平性，写者在没有获取到写锁的时候已经拥有了堵塞后续读者的权利，但是没有释放写锁来释放后续读者的权利。 说到公平性，可以思考一下 go 的读写锁是否实现了公平性？ 公平性：读者和写者的调度顺序。 如果读者和写者按照来的顺序调度，多个相邻的读者可以同时调度，我们说是公平的 在大多数情况下，读写是公平的，但是在释放写锁的时候，首先是给读者释放信号量，其次才是释放尝试加写锁时获取到的互斥锁，这一先后顺序会导致这一批读者中有一部分读者（调度机制）会先于写者调度，但实际上新的写者有可能才是先来的那位（在所有读者和写者中）。 读写锁的优先级： 读操作优先锁：提供了最大并发性，但在锁竞争比较激烈的情况下，可能会导致写操作饥饿。这是由于只要还有一个读线程持锁，写线程就拿不到锁。多个读者可以立刻拿到锁，这意味着一个写者可能一直在等锁，期间新的读者一直可以拿到锁。极端情况下，写者线程可能会一直等锁，直到所有一开始就拿到锁的读者释放锁。 写操作优先锁：如果队列中有写者在等锁，则阻止任何新读者拿锁，来避免了写操作饥饿的问题。一旦所有已经开始的读操作完成，等待的写操作立即获得锁。和读操作优先锁相比，写操作优先锁的不足在于在写者存在的情况下并发度低。内部实现需要两把互斥锁。 未指定优先级锁：不提供任何读/写的优先级保证。 go 的读写锁是写操作优先。 ","date":"2024-05-01","objectID":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/:3:0","tags":["language/go"],"title":"go 读写锁源码阅读","uri":"/posts/go-%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"categories":null,"content":"前言 go 中常常使用 context 来作为协程之间传递消息。使用场景常常有： 传递一个任务的元信息：在微服务中，常常将 traceID 写入在上下文的键值对中，用于追踪一个请求的调用链。 传递取消信号：父协程并发开启子协程执行任务，但是父协程也许会检测到什么信号（时间截止、任务结束），这个时候父协程可以使用 context 的取消功能结束所有子协程。 在使用的过程中，我常常有疑问： 不同函数之间传递的 context 对象是值引用还是指针引用 父子协程同时访问 context 并发安全吗 父协程执行取消函数做了什么？子协程开启的孙协程也会终止吗？ 带着问题，我阅读了 context 的源码（go 版本 1.19），了解了 context 的设计。 ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:1:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"类型 上下文一共有以下 4 种类型： emptyCtx：最基础的 context，只是表征一个类型 valueCtx：带键值对的context cancelCtx：带取消功能的context timerCtx：带定时取消功能的 context 在这 4 中类型中，最重要的是 valueCtx、cancelCtx，两者可以构建 context 包的几乎所有功能。 context 包定义了一组接口： type Context interface { Deadline() (deadline time.Time, ok bool) // 用于子协程获取deadline Done() \u003c-chan struct{} // 用于子协程获取管道的取消信号 Err() error // 返回上下文被取消或超时时的错误信息 Value(key any) any // 用于获取键值对 } 只要实现这一组接口就算就能算作 Context 类型。 ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:2:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"Background Background ：一个不懂 context 使用方法的新手用来作为调用函数的默认 context 参数的函数. 从规范来讲上，Backgroud 方法返回的 context 应该作为一个任务（请求）的根上下文。源码中的 Backgroud 方法返回一个初始化时生成的 emptyCtx： type emptyCtx int var ( background = new(emptyCtx) ) func Background() Context { return background } emptyCtx 在后文中的键值对 context 中实际上是作为子 context 往上回溯所有 context 的时的终结标志 ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:3:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"valueCtx 先来看带键值对的 ctx，因为带取消功能的 ctx 依赖带键值对的 ctx。 结构如下，实际上就是一个链表： type valueCtx struct { Context // 指向父context的指针 key, val any // 键值对 } 如何获得一个在现有 ctx 基础之上添加一个新键值对的 ctx： func WithValue(parent Context, key, val any) Context { if parent == nil { panic(\"cannot create context from nil parent\") } if key == nil { panic(\"nil key\") } if !reflectlite.TypeOf(key).Comparable() { panic(\"key is not comparable\") } return \u0026valueCtx{parent, key, val} } 创建一个新的 valueCtx，valueCtx.Context 指向父 ctx。在每个子任务的眼中，ctx 是一个链表，但是在整体视图中，ctx 组成的关系是一颗逆向树。 如何从 ctx 中获取存储的键值对信息： func value(c Context, key any) any { for { switch ctx := c.(type) { case *valueCtx: if key == ctx.key { return ctx.val } c = ctx.Context case *cancelCtx: if key == \u0026cancelCtxKey { return c } c = ctx.Context case *timerCtx: if key == \u0026cancelCtxKey { return \u0026ctx.cancelCtx } c = ctx.Context case *emptyCtx: return nil default: return c.Value(key) } } } func (c *valueCtx) Value(key any) any { if c.key == key { return c.val } return value(c.Context, key) } 可以先假设所有的 ctx 都是由 emptyCtx 添加键值对形成，那么获取目标键值对的过程就是从树的底部（子任务）往根节点遍历链表的过程，如果中途获取到目标键值对则返回，如果没有最后会遇到 emptyCtx，终止遍历返回空。（这反映了 Background 方法的重要性） 另外还值得一提的是，valueCtx 并没有设计更改设置好的键的值的 api，这是为了并发安全。 现在可以解答关于 valueCtx 的疑问了： 不同函数之间传递的 ctx 是值引用还是指针引用？ 指针引用 父子协程同时访问 context 并发安全吗？ 由于 valueCtx 是一个不可变对象，一旦构建之后，不能更改原有键的值，所以父子协程同时遍历键值对的时候不会设计到读写冲突。 ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:4:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"cancelCtx 结构： type cancelCtx struct { Context mu sync.Mutex // protects following fields done atomic.Value // of chan struct{}, created lazily, closed by first cancel call children map[canceler]struct{} // set to nil by the first cancel call err error // set to non-nil by the first cancel call } 如何获得一个在现有 ctx 基础之上添加取消控制的 ctx： func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { if parent == nil { panic(\"cannot create context from nil parent\") } c := newCancelCtx(parent) propagateCancel(parent, \u0026c) return \u0026c, func() { c.cancel(true, Canceled) } } 创建一个 cancelCtx，然后关键是 propagateCancel(parent, \u0026c)。 // propagateCancel arranges for child to be canceled when parent is. func propagateCancel(parent Context, child canceler) { done := parent.Done() if done == nil { return // parent is never canceled } select { case \u003c-done: // parent is already canceled child.cancel(false, parent.Err()) return default: } if p, ok := parentCancelCtx(parent); ok { p.mu.Lock() if p.err != nil { // parent has already been canceled child.cancel(false, p.err) } else { if p.children == nil { p.children = make(map[canceler]struct{}) } p.children[child] = struct{}{} } p.mu.Unlock() } else { atomic.AddInt32(\u0026goroutines, +1) go func() { select { case \u003c-parent.Done(): child.cancel(false, parent.Err()) case \u003c-child.Done(): } }() } } 首先检查父 ctx 是否结束，然后调用 parentCancelCtx(parent): func parentCancelCtx(parent Context) (*cancelCtx, bool) { done := parent.Done() if done == closedchan || done == nil { return nil, false } p, ok := parent.Value(\u0026cancelCtxKey).(*cancelCtx) if !ok { return nil, false } pdone, _ := p.done.Load().(chan struct{}) if pdone != done { return nil, false } return p, true } 可以看到还是先检查父 ctx 是否结束（为了并发安全），然后调用 parent.Value(\u0026cancelCtxKey).(*cancelCtx)，这一调用可以理解为将找到最近（向根节点遍历）的带有取消功能的 ctx。如果没有，说明创建的 cancelCtx 并不需要向父 ctx （整个链路）注册，因为创建的 cancelCtx 没有任何函数、协程控制。如果有，那么需要将指向最近的带有取消功能的 ctx 指针返回，用于注册创建的 cancelCtx。 看到这里，可以整理一下 cancelCtx 的整体视图（下图），cancelCtx 的遍历动作视图仍是 valueCtx 的配图，但是 cancelCtx 的控制动作是自顶向下的： 父协程是如何通过 ctx 控制管辖的子协程的？ ctx, cancel := context.WithCancel(context.Background()) 创建子 ctx 的同时，会分发给父协程一个 cancel 函数。父协程可以调用这一函数取消所有子协程。cancel 的源码如下： func (c *cancelCtx) cancel(removeFromParent bool, err error) { if err == nil { panic(\"context: internal error: missing cancel error\") } c.mu.Lock() if c.err != nil { c.mu.Unlock() return // already canceled } c.err = err d, _ := c.done.Load().(chan struct{}) if d == nil { c.done.Store(closedchan) } else { close(d) } for child := range c.children { // NOTE: acquiring the child's lock while holding parent's lock. child.cancel(false, err) } c.children = nil c.mu.Unlock() if removeFromParent { removeChild(c.Context, c) } } 对于第一个参数 removeFromParent，只有当当前 ctx 主动调用分发的 cancel 函数，才会为 true（分发的 cancel 函数：func() { c.cancel(true, Canceled) }）。这一参数为 true，将会在最近的带有取消功能的 ctx 注销当前的 ctx。比如，在 cancelCtx 整体视图中，如果节点 2 调用 cancel 函数，节点 1 中的 map 将删除节点 2 。调用 cancel 函数，传到的控制信息是自顶向下的（深度优先搜索），会给所有的节点发送取消信号，接受到取消信号的 cancelCtx 会继续向下传到取消信号…… ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:5:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"总结 以上便是 context 包的主要源码解读，主要是分析了 valueCtx 和 cancelCtx 的视图，解答了开始提出的几个问题。 ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:6:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"问题：星巴克售卖饮品，需要计算饮品的价格。饮品有几种基础饮品：无咖啡因咖啡、超优深焙咖啡、浓咖啡等等，每个基础饮品可以添加调料最后产生最终的饮品。由于星巴克扩张迅速，需要快速退出新品，调料和基础饮品都可以增加和改变，如何设计系统，才能优雅的应对调料和基础饮品的增加。 核心思想：用组合代替继承，来扩张类的功能 设计原则：类应该对扩展开放，对修改关闭 实现：一个最基础的类，这个类会有一个接口 cost，每个基础饮品都需要实现继承这个基础类，实现 cost 接口（基础饮品的价格）。装饰者类继承这个基础类（可以添加一些新的方法比如 printDescription()）, 每个装饰者都应该继承这个装饰者类或者实现这个装饰者类的接口（go 中的 interface） 缺陷：由于每个调料都是一个装饰者（类），在实现过程中，会依赖大量的类，声明大量类的实例，不便于管理，工厂模式和生成器模式会解决这个问题 示例代码： class beverage { string description; public: beverage() {} beverage(string s) : description(s) {} virtual string describe() { return description; } virtual double cost() = 0; }; class Espresso : public beverage { public: Espresso() : beverage(\"浓咖啡\") {} double cost() override { return 2.0; } }; class DarkRoast : public beverage { public: DarkRoast() : beverage(\"深焙咖啡\") {} double cost() override { return 3.0; } }; class condimentDecorater : public beverage { public: virtual string describe() = 0; condimentDecorater() {}; }; class milk : public condimentDecorater { beverage \u0026b; public: milk(beverage \u0026b) : b(b) {} string describe() { return b.describe() + \"+牛奶\"; } double cost() { return b.cost() + 0.5; } }; class mocha : public condimentDecorater { beverage \u0026b; public: mocha(beverage \u0026b) : b(b) {} string describe() { return b.describe() + \"+摩卡\"; } double cost() { return b.cost() + 1; } }; int main() { Espresso espresso; DarkRoast darkRoast; beverage *milkEspresso = new milk(espresso); beverage *mochaDarkRoast = new mocha(darkRoast); cout \u003c\u003c milkEspresso-\u003edescribe() \u003c\u003c \" cost:\" \u003c\u003c milkEspresso-\u003ecost() \u003c\u003c endl; cout \u003c\u003c mochaDarkRoast-\u003edescribe() \u003c\u003c \" cost:\" \u003c\u003c mochaDarkRoast-\u003ecost() \u003c\u003c endl; return 0; } 示例非常简单，几乎不涉及什么内存管理，当装饰者模式设计到复杂的对象的时候，可以考虑使用 c++的智能指针来管理内存，毕竟装饰者模式会涉及非常多的对象和相互引用。 ","date":"2024-03-01","objectID":"/posts/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计/模式"],"title":"装饰者模式","uri":"/posts/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"}]