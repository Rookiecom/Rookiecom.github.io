[{"categories":null,"content":"前言 go 中常常使用 context 来作为协程之间传递消息。使用场景常常有： 传递一个任务的元信息：在微服务中，常常将 traceID 写入在上下文的键值对中，用于追踪一个请求的调用链。 传递取消信号：父协程并发开启子协程执行任务，但是父协程也许会检测到什么信号（时间截止、任务结束），这个时候父协程可以使用 context 的取消功能结束所有子协程。 在使用的过程中，我常常有疑问： 不同函数之间传递的 context 对象是值引用还是指针引用 父子协程同时访问 context 并发安全吗 父协程执行取消函数做了什么？子协程开启的孙协程也会终止吗？ 带着问题，我阅读了 context 的源码（go 版本 1.19），了解了 context 的设计。 ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:1:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"类型 上下文一共有以下 4 种类型： emptyCtx：最基础的 context，只是表征一个类型 valueCtx：带键值对的context cancelCtx：带取消功能的context timerCtx：带定时取消功能的 context 在这 4 中类型中，最重要的是 valueCtx、cancelCtx，两者可以构建 context 包的几乎所有功能。 context 包定义了一组接口： type Context interface { Deadline() (deadline time.Time, ok bool) // 用于子协程获取deadline Done() \u003c-chan struct{} // 用于子协程获取管道的取消信号 Err() error // 返回上下文被取消或超时时的错误信息 Value(key any) any // 用于获取键值对 } 只要实现这一组接口就算就能算作 Context 类型。 ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:2:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"Background Background ：一个不懂 context 使用方法的新手用来作为调用函数的默认 context 参数的函数. 从规范来讲上，Backgroud 方法返回的 context 应该作为一个任务（请求）的根上下文。源码中的 Backgroud 方法返回一个初始化时生成的 emptyCtx： type emptyCtx int var ( background = new(emptyCtx) ) func Background() Context { return background } emptyCtx 在后文中的键值对 context 中实际上是作为子 context 往上回溯所有 context 的时的终结标志 ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:3:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"valueCtx 先来看带键值对的 ctx，因为带取消功能的 ctx 依赖带键值对的 ctx。 结构如下，实际上就是一个链表： type valueCtx struct { Context // 指向父context的指针 key, val any // 键值对 } 如何获得一个在现有 ctx 基础之上添加一个新键值对的 ctx： func WithValue(parent Context, key, val any) Context { if parent == nil { panic(\"cannot create context from nil parent\") } if key == nil { panic(\"nil key\") } if !reflectlite.TypeOf(key).Comparable() { panic(\"key is not comparable\") } return \u0026valueCtx{parent, key, val} } 创建一个新的 valueCtx，valueCtx.Context 指向父 ctx。在每个子任务的眼中，ctx 是一个链表，但是在整体视图中，ctx 组成的关系是一颗逆向树。 如何从 ctx 中获取存储的键值对信息： func value(c Context, key any) any { for { switch ctx := c.(type) { case *valueCtx: if key == ctx.key { return ctx.val } c = ctx.Context case *cancelCtx: if key == \u0026cancelCtxKey { return c } c = ctx.Context case *timerCtx: if key == \u0026cancelCtxKey { return \u0026ctx.cancelCtx } c = ctx.Context case *emptyCtx: return nil default: return c.Value(key) } } } func (c *valueCtx) Value(key any) any { if c.key == key { return c.val } return value(c.Context, key) } 可以先假设所有的 ctx 都是由 emptyCtx 添加键值对形成，那么获取目标键值对的过程就是从树的底部（子任务）往根节点遍历链表的过程，如果中途获取到目标键值对则返回，如果没有最后会遇到 emptyCtx，终止遍历返回空。（这反映了 Background 方法的重要性） 另外还值得一提的是，valueCtx 并没有设计更改设置好的键的值的 api，这是为了并发安全。 现在可以解答关于 valueCtx 的疑问了： 不同函数之间传递的 ctx 是值引用还是指针引用？ 指针引用 父子协程同时访问 context 并发安全吗？ 由于 valueCtx 是一个不可变对象，一旦构建之后，不能更改原有键的值，所以父子协程同时遍历键值对的时候不会设计到读写冲突。 ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:4:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"cancelCtx 结构： type cancelCtx struct { Context mu sync.Mutex // protects following fields done atomic.Value // of chan struct{}, created lazily, closed by first cancel call children map[canceler]struct{} // set to nil by the first cancel call err error // set to non-nil by the first cancel call } 如何获得一个在现有 ctx 基础之上添加取消控制的 ctx： func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { if parent == nil { panic(\"cannot create context from nil parent\") } c := newCancelCtx(parent) propagateCancel(parent, \u0026c) return \u0026c, func() { c.cancel(true, Canceled) } } 创建一个 cancelCtx，然后关键是 propagateCancel(parent, \u0026c)。 // propagateCancel arranges for child to be canceled when parent is. func propagateCancel(parent Context, child canceler) { done := parent.Done() if done == nil { return // parent is never canceled } select { case \u003c-done: // parent is already canceled child.cancel(false, parent.Err()) return default: } if p, ok := parentCancelCtx(parent); ok { p.mu.Lock() if p.err != nil { // parent has already been canceled child.cancel(false, p.err) } else { if p.children == nil { p.children = make(map[canceler]struct{}) } p.children[child] = struct{}{} } p.mu.Unlock() } else { atomic.AddInt32(\u0026goroutines, +1) go func() { select { case \u003c-parent.Done(): child.cancel(false, parent.Err()) case \u003c-child.Done(): } }() } } 首先检查父 ctx 是否结束，然后调用 parentCancelCtx(parent): func parentCancelCtx(parent Context) (*cancelCtx, bool) { done := parent.Done() if done == closedchan || done == nil { return nil, false } p, ok := parent.Value(\u0026cancelCtxKey).(*cancelCtx) if !ok { return nil, false } pdone, _ := p.done.Load().(chan struct{}) if pdone != done { return nil, false } return p, true } 可以看到还是先检查父 ctx 是否结束（为了并发安全），然后调用 parent.Value(\u0026cancelCtxKey).(*cancelCtx)，这一调用可以理解为将找到最近（向根节点遍历）的带有取消功能的 ctx。如果没有，说明创建的 cancelCtx 并不需要向父 ctx （整个链路）注册，因为创建的 cancelCtx 没有任何函数、协程控制。如果有，那么需要将指向最近的带有取消功能的 ctx 指针返回，用于注册创建的 cancelCtx。 看到这里，可以整理一下 cancelCtx 的整体视图（下图），cancelCtx 的遍历动作视图仍是 valueCtx 的配图，但是 cancelCtx 的控制动作是自顶向下的： 父协程是如何通过 ctx 控制管辖的子协程的？ ctx, cancel := context.WithCancel(context.Background()) 创建子 ctx 的同时，会分发给父协程一个 cancel 函数。父协程可以调用这一函数取消所有子协程。cancel 的源码如下： func (c *cancelCtx) cancel(removeFromParent bool, err error) { if err == nil { panic(\"context: internal error: missing cancel error\") } c.mu.Lock() if c.err != nil { c.mu.Unlock() return // already canceled } c.err = err d, _ := c.done.Load().(chan struct{}) if d == nil { c.done.Store(closedchan) } else { close(d) } for child := range c.children { // NOTE: acquiring the child's lock while holding parent's lock. child.cancel(false, err) } c.children = nil c.mu.Unlock() if removeFromParent { removeChild(c.Context, c) } } 对于第一个参数 removeFromParent，只有当当前 ctx 主动调用分发的 cancel 函数，才会为 true（分发的 cancel 函数：func() { c.cancel(true, Canceled) }）。这一参数为 true，将会在最近的带有取消功能的 ctx 注销当前的 ctx。比如，在 cancelCtx 整体视图中，如果节点 2 调用 cancel 函数，节点 1 中的 map 将删除节点 2 。调用 cancel 函数，传到的控制信息是自顶向下的（深度优先搜索），会给所有的节点发送取消信号，接受到取消信号的 cancelCtx 会继续向下传到取消信号…… ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:5:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"总结 以上便是 context 包的主要源码解读，主要是分析了 valueCtx 和 cancelCtx 的视图，解答了开始提出的几个问题。 ","date":"2024-03-30","objectID":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/:6:0","tags":["language/go"],"title":"go context底层原理","uri":"/posts/go-context%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"问题：星巴克售卖饮品，需要计算饮品的价格。饮品有几种基础饮品：无咖啡因咖啡、超优深焙咖啡、浓咖啡等等，每个基础饮品可以添加调料最后产生最终的饮品。由于星巴克扩张迅速，需要快速退出新品，调料和基础饮品都可以增加和改变，如何设计系统，才能优雅的应对调料和基础饮品的增加。 核心思想：用组合代替继承，来扩张类的功能 设计原则：类应该对扩展开放，对修改关闭 实现：一个最基础的类，这个类会有一个接口 cost，每个基础饮品都需要实现继承这个基础类，实现 cost 接口（基础饮品的价格）。装饰者类继承这个基础类（可以添加一些新的方法比如 printDescription()）, 每个装饰者都应该继承这个装饰者类或者实现这个装饰者类的接口（go 中的 interface） 缺陷：由于每个调料都是一个装饰者（类），在实现过程中，会依赖大量的类，声明大量类的实例，不便于管理，工厂模式和生成器模式会解决这个问题 示例代码： class beverage { string description; public: beverage() {} beverage(string s) : description(s) {} virtual string describe() { return description; } virtual double cost() = 0; }; class Espresso : public beverage { public: Espresso() : beverage(\"浓咖啡\") {} double cost() override { return 2.0; } }; class DarkRoast : public beverage { public: DarkRoast() : beverage(\"深焙咖啡\") {} double cost() override { return 3.0; } }; class condimentDecorater : public beverage { public: virtual string describe() = 0; condimentDecorater() {}; }; class milk : public condimentDecorater { beverage \u0026b; public: milk(beverage \u0026b) : b(b) {} string describe() { return b.describe() + \"+牛奶\"; } double cost() { return b.cost() + 0.5; } }; class mocha : public condimentDecorater { beverage \u0026b; public: mocha(beverage \u0026b) : b(b) {} string describe() { return b.describe() + \"+摩卡\"; } double cost() { return b.cost() + 1; } }; int main() { Espresso espresso; DarkRoast darkRoast; beverage *milkEspresso = new milk(espresso); beverage *mochaDarkRoast = new mocha(darkRoast); cout \u003c\u003c milkEspresso-\u003edescribe() \u003c\u003c \" cost:\" \u003c\u003c milkEspresso-\u003ecost() \u003c\u003c endl; cout \u003c\u003c mochaDarkRoast-\u003edescribe() \u003c\u003c \" cost:\" \u003c\u003c mochaDarkRoast-\u003ecost() \u003c\u003c endl; return 0; } 示例非常简单，几乎不涉及什么内存管理，当装饰者模式设计到复杂的对象的时候，可以考虑使用 c++的智能指针来管理内存，毕竟装饰者模式会涉及非常多的对象和相互引用。 ","date":"2024-03-01","objectID":"/posts/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计/模式"],"title":"装饰者模式","uri":"/posts/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"}]